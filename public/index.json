[{"authors":null,"categories":["R"],"content":"Comme on a pu le voir par exemple dans le précédent post, l’aggrégation est souvent utilisée en analyse de données. Il est donc intéressant de comparer les performances des différentes options que propose R de ce point de vue. Des benchmarks comparant data.table, dplyr et la librairie pandas de python sur différentes tailles de tables ont déjà été faits, vous pouvez les trouver sur cette page github. On propose ici quelques tests comparatifs complémentaires sur un cas d’un calcul simple à partir d’un groupement d’une base fictive de nbrow lignes appartenant à nbgpe groupes. La fonction s’applique à deux variables numériques x et y, la première étant une variable aléatoire et la seconde un entier dont on fait varier le nombre de modalités. On teste l’instruction suivante :\nPour dplyr\ndatatib %\u0026gt;% group_by(y) %\u0026gt;% summarise(x = mean(x))\rPour data.table\ndataDT[, .(x = mean(x)), by = .(y = y)]\rPour base R\ntap \u0026lt;- tapply(test$x, test$y, mean)\rdata.frame(x = tap, y = names(tap))\rNotons que dans ce cas, on ajoute une étape pour transformer l’output doit être un dataframe. On aurait aussi pu utiliser la fonction aggregate qui permet cela.\nIl n’y a plus qu’à tester! On propose des tests sur 10 000, 100 000 et 1 million de lignes avec à chaque fois peu (1/1000e du nombre de lignes) ou beaucoup (la moitié du nombre de lignes) de groupes. On fait un tableau récapitulatif des différents graphiques issus de la fonction autoplot de ggplot2 qui sort joliment les résultats de microbenchmark (on regroupe ces graphiques à l’aide du package gridExtra). Les graphiques représentent la distribution des 30 occurences testées par méthode en fonction de leur temps d’exécution.\nLe premier constat est que la méthode data.table est toujours plus rapide que les alternatives testées. Le second est que R base concurrence dplyr dans tous les cas où le nombre de groupes sur lesquels il faut agréger est petit. Au contraire, la fonction tapply est largement en dessous des performances des deux autres options quand le nombre de groupes est élevé.\nLe changement d’échelle du graphique à chaque hypothèse testée est trompeur mais ne doit pas cacher que dans le cas d’une table à 1 million de lignes et 50 000 groupes, si l’option dplyr fait largement mieux que R base, elle est aussi plus surpassée que jamais par data.table. Il est intéressant de zoomer sur ce cas pour mieux s’en rendre compte :\nLes temps d’exécution de data.table ne dépassent pas 200 millisecondes alors que ceux de dplyr naviguent de 700 ms à un peu plus de 1 seconde, soit environ 4 fois plus.\nCes tests confirment ceux cités en introduction de ce post. Ils montrent l’intérêt d’utiliser data.table dans le cas d’instructions agrégées si l’on souhaite optimiser le temps d’exécution de son script et/ou si l’on connaît des difficultés à gérer des tables volumineuses. Ils montrent aussi que dplyr reste une option crédible et très compétitive notamment par rapport aux fonctions de base R.\n","date":1544486400,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1544486400,"objectID":"9cd901bcec499a0e6e0f5d220a1b87e2","permalink":"/post/vitesses-d-agr%C3%A9gation-de-data-table-et-dplyr/","publishdate":"2018-12-11T00:00:00Z","relpermalink":"/post/vitesses-d-agr%C3%A9gation-de-data-table-et-dplyr/","section":"post","summary":"Comme on a pu le voir par exemple dans le précédent post, l’aggrégation est souvent utilisée en analyse de données. Il est donc intéressant de comparer les performances des différentes options que propose R de ce point de vue. Des benchmarks comparant data.table, dplyr et la librairie pandas de python sur différentes tailles de tables ont déjà été faits, vous pouvez les trouver sur cette page github. On propose ici quelques tests comparatifs complémentaires sur un cas d’un calcul simple à partir d’un groupement d’une base fictive de nbrow lignes appartenant à nbgpe groupes.","tags":["benchmark","data.table","dplyr","tidyverse","microbenchmark"],"title":"Vitesses d'aggrégation de base R, data.table et dplyr","type":"post"},{"authors":null,"categories":["R"],"content":"La richesse de R, alimentée par une communauté de développeurs très active, rend le choix d’une méthode adaptée à une problématique donnée difficile, et c’est tant mieux. Vous trouverez ici une modeste participation au débat qui oppose les deux packages d’analyse des données les plus en vue dans la communauté R : data.table et dplyr. L’article se présente en deux parties :\n\rUn rappel sur les syntaxes de dplyr et data.table, que vous pouvez passer si vous connaissez déjà les packages.\rUne comparaison de l’efficacité des deux packages sur une étude de cas à partir des données du package nycflights13\r\rRappels sur dplyr et data.table\rSi vous connaissez déjà la syntaxe de ces packages, vous pouvez directement aller à la partie Comparaisons sur une étude de cas simple. On rappelle ici les principales caractéristiques de ces packages mais pour se former à leur utilisation on peut se référer au cours de perfectionnement de Martin Chevalier. Pour une exploration de ce qu’englobe le tidyverse et notamment une présentation des commandes de dplyr, vous pouvez jeter un oeil à l’introduction à R et au tidyverse de J. Barnier. Enfin pour data.table, on trouve des informations utiles sur le cours Manipulations avancée avec data.table de J. Larmarange.\ndplyr et le tidyverse\rLe tidyverse (contraction de “tidy” et “universe”) est un concept initié par Hadley Wickham, chef statisticien de RStudio. Il regroupe un ensemble de packages utiles au traitement statistique et au nettoyage de bases de données. On va s’intéresser ici presque seulement au package dplyr (dont les instructions seront appliquées aux tibbles, un format de data.frame issu du tidyverse), mais vous pouvez parcourir les packages proposés dans le tidyverse sur le site officiel.\ndplyr propose un ensemble d’opérations de traitement de données sous une syntaxe différente de celle utilisée dans les fonctions de base de R. Ce langage présente le double avantage d’être à la fois lisible pour quelqu’un habitué aux langages tels que SAS ou SQL et de proposer des fonctions optimisées qui présentent de bonnes performances en termes de temps d’exécution. La grammaire dplyr s’appuie en effet sur des fonctions au nom explicite :\n\rmutate(data, newvar1=fonction(var1,var2...)) et transmute(data, newvar1=fonction(var1,var2...)) créent de nouvelles variables\rfilter(data, condition) sélectionne au sein d’une table certaines observations, à la manière de where dans SAS.\rarrange(data, var1, descending var2,...) trie une base selon une ou plusieurs variables (l’équivalent d’une proc sort).\rselect(data, var1 : varX) sélectionne certaines variables dans une base, à la manière de keep dans SAS.\rsummarise(data, newvar1=mean(var1), newvar2=sum(var2)) réalise toute sorte d’opérations statistiques sur une table.\rgroup_by(data, var) regroupe une table par une variable\ret bien d’autres…\r\rUn aspect pratique de ce langage est que toutes ces opérations peuvent être chaînées à l’aide de l’opérateur %\u0026gt;% (“pipe” en anglais) dont la syntaxe est la suivante : data %\u0026gt;% fonction(...) est équivalent à fonction(data, ...). Cette syntaxe permet de chaîner un grand nombre d’opérations sur une base commune, en limitant le nombre de fois où l’on écrit des tables intermédiaires tout en conservant une grande lisibilité du code. Ce petit exemple vous en convaincra peut-être :\nlibrary(tidyverse) # On aurait aussi pu charger seulement le package dplyr\r# on crée un data frame avec 100 lignes, chaque individu appartenant à un des 50 groupes\rdf \u0026lt;- data.frame(id1 = c(1:100), idgpe = sample(50), replace = TRUE)\r# on y applique les instructions de dplyr\rdf %\u0026gt;% as_tibble() %\u0026gt;% mutate(var = rnorm(100)) %\u0026gt;% group_by(idgpe) %\u0026gt;% summarise(var_mean = mean(var)) -\u0026gt; output_tibble\rUn regard peu habitué contesterait peut-être l’aspect très lisible de l’instruction, mais ça l’est réellement. Le déroulé est le suivant :\non transforme notre data.frame en tibble (pour rappel : format optimisé de data.frame pour dplyr) avec as_tibble\n\ron crée une variable var avec mutate\n\ron agrège par idgpe avec group_by\n\ron calcule la moyenne de var avec summarise, que l’on stocke dans var_mean. Comme cette instruction suit un group_by, elle est réalisée à l’intérieur de chaque groupe (défini par idgpe), sinon elle aurait été réalisé sur l’ensemble de la table.\r\rTout cela est stocké dans une table output_tibble, qui est ainsi un tibble agrégé par idgpe et qui a donc 50 lignes. L’intérêt de ce chaînage est qu’il permet une économie de code et d’écriture d’éventuelles tables intermédiaires.\n\rData.table\rLe package data.table ne prétend pas, contrairement au tidyverse, proposer une syntaxe concurrente à base R mais enrichir celle-ci. Il est axé autour d’un nouveau format d’objet, le data.table, qui est un type de data.frame qui permet une utilisation optimisée de l’opérateur [.\nTout data.frame peut être converti en data.table grâce à la fonction as.data.table, ou, de manière plus optimale pour l’utilisation de la mémoire, grâce à la fonction setDT qui permet de directement transformer la nature de l’objet sans avoir à en écrire un autre. Il est important d’avoir en tête qu’un data.frame converti en data.table conserve les caractéristiques d’un data.frame. Cependant, l’opérateur [ appliqué au data.table change de signification et devient :\nDT[i,j,by]\rAvec i qui permet de sélectionner des observations (sans avoir besoin de répéter le nom de la base dans laquelle on se trouve), j qui permet de créer ou sélectionner des variables et by de regrouper les traitement selon les modalités d’une variable définie. Comme dans dplyr, il est possible de chaîner les opérations réalisées comme le montre l’exemple suivant, qui reprend le même cas de figure que celui illustrant le package dplyr :\nlibrary(data.table) # on convertit notre data frame précédemment créé en data.table\rdt \u0026lt;- as.data.table(df)\r# on y applique les même instructions\rdt[, list(var_mean = mean(rnorm(100))), by = list(idgpe = idgpe)] -\u0026gt; output_dt\rLe fait de renseigner mes variables au sein de list() me permet d’avoir une table en sortie au niveau de idgpe (donc 50 observations), sans cela ma variable est bien moyennée par groupe mais la table en sortie est toujours au niveau id1 (100 observations).\n\rVitesses d’exécution\rVoilà donc pour les présentations! Allez, on montre le résultat d’un petit microbenchmark des deux juste pour voir :\n## Unit: microseconds\r## expr min lq mean median uq max neval\r## dplyr 1531.449 1567.289 1753.4469 1596.303 1856.0005 4545.422 100\r## data.table 819.201 856.178 919.2454 901.405 974.7915 1233.921 100\rSur cet exemple, on voit un avantage clair à data.table! Mais on est sur une toute petite table en entrée. On va essayer de se rapprocher de cas plus concrets en s’intéressant à un exemple sur des bases plus importantes.\n\r\rComparaisons sur une étude de cas simple\rLes avantages et inconvénients de ces deux packages sont à l’origine de nombreux débats. Vous pouvez vous en convaincre en suivant cette discussion sur stackoverflow. On peut quand même dégager deux compromis :\n\rLe choix de l’un ou l’autre des packages dépend beaucoup de ce que l’on va en faire (types d’analyses, taille des données, profils des utilisateurs du code…).\n\rLes deux packages sont plus intéressants que base R pour l’analyse de données, que ce soit en termes de facilité d’écriture ou de performances.\r\rPour ce deuxième point, on va essayer de s’en convaincre ensemble avec ce petit exemple.\nNotre étude de cas\rPour cet exemple, on utilise les données du package de Hadley Wickham que l’on trouve dans nycflights13. En particulier, la base flights donne toutes les heures de départ et d’arrivée selon les aéroports de départ et d’arrivée ainsi que les retards au départ et à l’arrivée. La base weather donne elle des indications météo, heure par heure, dans chaque aéroport. Tout bon statisticien qui se respecte devrait commencer à se dire qu’il y a quelque chose à faire pour tenter d’expliquer les retards des avions (spoiler alert : on ne va pas le faire).\nCommençons par charger nos packages (n’oubliez pas de faire install.packages(\u0026quot;nom_pck\u0026quot;) avant si vous ne l’avez jamais fait) et nos données :\n# Les packages nécessaires\rlibrary(tidyverse) # Regroupe différents packages, voir https://www.tidyverse.org/ library(data.table)\rlibrary(microbenchmark) # Pour les calculs de vitesse d\u0026#39;exécution\rlibrary(nycflights13) # Pour les données\r# data.table pour tests avec data.table\rflightsdt \u0026lt;- as.data.table(flights)\rweatherdt \u0026lt;- as.data.table(weather)\rNotez que l’on n’est pas obligés de faire du dplyr sur des tibbles plutôt que des data frame, mais on suit ici les recommandations d’Hadley Wickham.\n\rMoyenne des retards et fusion des tables\rUn rapide examen des bases vous montre que la première étape avant toute analyse est comme souvent de regrouper les éléments de flights par heure et aéroport de départ pour pouvoir les fusionner avec la table weather, qui donnent les indications météo minute par minute. On écrit cette instruction de 3 manières différentes :\nEn base R\nflights_time_hour \u0026lt;- aggregate.data.frame(list(arr_delay = flights$arr_delay, dep_delay = flights$dep_delay), list(time_hour = flights$time_hour, origin = flights$origin), mean)\routput_base \u0026lt;- merge(weather, flights_time_hour, by = c(\u0026quot;time_hour\u0026quot;, \u0026quot;origin\u0026quot;), sort = FALSE)\r(J’ai utilisé aggregate.data.frame et pas tapply pour avoir directement un data.frame en sortie)\nEn dplyr\nflights %\u0026gt;% group_by(time_hour, origin) %\u0026gt;% summarise(arr_delay = mean(arr_delay),\rdep_delay = mean(dep_delay)) %\u0026gt;% inner_join(weather, by = c(\u0026quot;time_hour\u0026quot;, \u0026quot;origin\u0026quot;)) -\u0026gt; output_dplyr \rEn data.table\noutput_DT \u0026lt;- merge(flightsdt[, list(arr_perc_delay = mean(arr_delay),\rdep_perc_delay = mean(dep_delay)), by = c(\u0026quot;time_hour\u0026quot;, \u0026quot;origin\u0026quot;)],\rweatherdt, by = c(\u0026quot;time_hour\u0026quot;, \u0026quot;origin\u0026quot;))\rJ’ai utilisé la fonction merge plutôt que DT1[DT2, on = c(\u0026quot;time_hour\u0026quot;, \u0026quot;origin\u0026quot;), nomatch = 0] car j’ai constaté qu’elle était plus rapide, conformément à ce que montre bien cet article du Jozef’s Rblog.\n\rComparaisons des vitesses d’exécution\rJe vous laisse juger de la lisibilité de chacune de ces instructions, qui font toutes la même chose, car c’est finalement assez subjectif. On donne ici les résultats d’un microbenchmark de ces instructions :\n## Unit: milliseconds\r## expr min lq mean median uq max\r## Base 2313.60446 2492.01024 2631.20076 2704.05612 2753.71612 2868.66635\r## DplyR 55.56166 58.76165 62.45664 61.29150 65.58718 71.77726\r## DT 32.77311 33.92625 35.76353 35.02335 38.23842 39.83814\r## neval\r## 10\r## 10\r## 10\rLes résultats sont très nettement en faveur des packages dplyr et data.table, ce dernier ayant l’avantage. Sans doute existe-t-il des moyens de plus optimiser l’instruction en base R, mais là n’est pas vraiment la question. On voit qu’avec une syntaxe simple et lisible, dplyr et data.table font beaucoup mieux que l’instruction qui viendrait à l’esprit d’un statisticien qui n’utiliserait que les premières fonctions venues de base R.\n\r\r","date":1543795200,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1543858369,"objectID":"4a2710bcf63721f06fd2ebd9ae7fbbc7","permalink":"/post/comparaisons-base-r-dplyr-data-table/","publishdate":"2018-12-03T00:00:00Z","relpermalink":"/post/comparaisons-base-r-dplyr-data-table/","section":"post","summary":"La richesse de R, alimentée par une communauté de développeurs très active, rend le choix d’une méthode adaptée à une problématique donnée difficile, et c’est tant mieux. Vous trouverez ici une modeste participation au débat qui oppose les deux packages d’analyse des données les plus en vue dans la communauté R : data.table et dplyr. L’article se présente en deux parties :\n\rUn rappel sur les syntaxes de dplyr et data.","tags":["benchmark","data science","data.table","dplyr","microbenchmark","tidyverse","R"],"title":"Comparaisons base R - dplyr - data.table","type":"post"}]