<!DOCTYPE html>
<html lang="fr">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 2.4.0">
  <meta name="generator" content="Hugo 0.49" />
  <meta name="author" content="Antoine Sireyjol">

  
  
  
  
    
  
  <meta name="description" content="1 Rappels sur dplyr et data.table1.1 dplyr et le tidyverse1.2 Data.table1.3 Vitesses d’exécution2 Comparaisons sur une étude de cas simple2.1 Notre étude de cas2.2 Moyenne des retards et fusion des tables2.3 Comparaisons des vitesses d’exécution3 Tests complémentaires sur les vitesse d’aggrégation4 Bonus : une propriété étonnante de dplyrLa richesse de R, alimentée par une communauté de développeurs très active, rend le choix d’une méthode adaptée à une problématique donnée difficile, et c’est tant mieux.">

  
  <link rel="alternate" hreflang="fr" href="/post/benchmark_dt_dplyr_base_102018/">

  


  

  
  
  
  <meta name="theme-color" content="#D32121">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous">
        
      
    

    

    

  

  
  
  <link rel="stylesheet" href=//fonts.googleapis.com/css?family=Playfair+Display:400,700|Fauna+One>
  

  <link rel="stylesheet" href="/styles.css">
  
  <link rel="stylesheet" href="/css/custom.css">
  

  
  
  

  
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Antoine Sireyjol">
  <link rel="feed" href="/index.xml" type="application/rss+xml" title="Antoine Sireyjol">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/post/benchmark_dt_dplyr_base_102018/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="Antoine Sireyjol">
  <meta property="og:url" content="/post/benchmark_dt_dplyr_base_102018/">
  <meta property="og:title" content="Comparaisons entre dplyr, data.table et base R | Antoine Sireyjol">
  <meta property="og:description" content="1 Rappels sur dplyr et data.table1.1 dplyr et le tidyverse1.2 Data.table1.3 Vitesses d’exécution2 Comparaisons sur une étude de cas simple2.1 Notre étude de cas2.2 Moyenne des retards et fusion des tables2.3 Comparaisons des vitesses d’exécution3 Tests complémentaires sur les vitesse d’aggrégation4 Bonus : une propriété étonnante de dplyrLa richesse de R, alimentée par une communauté de développeurs très active, rend le choix d’une méthode adaptée à une problématique donnée difficile, et c’est tant mieux.">
  
  
    
  <meta property="og:image" content="/img/icon-192.png">
  <meta property="og:locale" content="fr">
  
  <meta property="article:published_time" content="2018-11-01T00:00:00&#43;00:00">
  
  <meta property="article:modified_time" content="2018-11-01T00:00:00&#43;00:00">
  

  

  

  <title>Comparaisons entre dplyr, data.table et base R | Antoine Sireyjol</title>

</head>
<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" >

<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Antoine Sireyjol</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Ouvrir la barre de navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav ml-auto">
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#hero">
            
            <span>Accueil</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#posts">
            
            <span>Le blog</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#publications">
            
            <span>Publications</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#contact">
            
            <span>Contact</span>
            
          </a>
        </li>

        
        

      

        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">Comparaisons entre dplyr, data.table et base R</h1>

    

<div class="article-metadata">

  
  
  <span itemscope itemprop="author" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Antoine Sireyjol">
  </span>
  

  <span class="article-date">
    
    <meta content="2018-11-01 00:00:00 &#43;0000 UTC" itemprop="datePublished">
    <time datetime="2018-11-01 00:00:00 &#43;0000 UTC" itemprop="dateModified">
      Nov 1, 2018
    </time>
  </span>
  <span itemscope itemprop="publisher" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Antoine Sireyjol">
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    12 min de lecture
  </span>
  

  
  

  
  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder"></i>
    
    <a href="/categories/r/">R</a>
    
  </span>
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Comparaisons%20entre%20dplyr%2c%20data.table%20et%20base%20R&amp;url=%2fpost%2fbenchmark_dt_dplyr_base_102018%2f"
         target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=%2fpost%2fbenchmark_dt_dplyr_base_102018%2f"
         target="_blank" rel="noopener">
        <i class="fab fa-facebook-f"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fpost%2fbenchmark_dt_dplyr_base_102018%2f&amp;title=Comparaisons%20entre%20dplyr%2c%20data.table%20et%20base%20R"
         target="_blank" rel="noopener">
        <i class="fab fa-linkedin-in"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=%2fpost%2fbenchmark_dt_dplyr_base_102018%2f&amp;title=Comparaisons%20entre%20dplyr%2c%20data.table%20et%20base%20R"
         target="_blank" rel="noopener">
        <i class="fab fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Comparaisons%20entre%20dplyr%2c%20data.table%20et%20base%20R&amp;body=%2fpost%2fbenchmark_dt_dplyr_base_102018%2f">
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>


    <div class="article-style" itemprop="articleBody">
      <div id="TOC">
<ul>
<li><a href="#rappels-sur-dplyr-et-data.table"><span class="toc-section-number">1</span> Rappels sur dplyr et data.table</a><ul>
<li><a href="#dplyr-et-le-tidyverse"><span class="toc-section-number">1.1</span> dplyr et le tidyverse</a></li>
<li><a href="#data.table"><span class="toc-section-number">1.2</span> Data.table</a></li>
<li><a href="#vitesses-dexecution"><span class="toc-section-number">1.3</span> Vitesses d’exécution</a></li>
</ul></li>
<li><a href="#comparaisons-sur-une-etude-de-cas-simple"><span class="toc-section-number">2</span> Comparaisons sur une étude de cas simple</a><ul>
<li><a href="#notre-etude-de-cas"><span class="toc-section-number">2.1</span> Notre étude de cas</a></li>
<li><a href="#moyenne-des-retards-et-fusion-des-tables"><span class="toc-section-number">2.2</span> Moyenne des retards et fusion des tables</a></li>
<li><a href="#comparaisons-des-vitesses-dexecution"><span class="toc-section-number">2.3</span> Comparaisons des vitesses d’exécution</a></li>
</ul></li>
<li><a href="#tests-complementaires-sur-les-vitesse-daggregation"><span class="toc-section-number">3</span> Tests complémentaires sur les vitesse d’aggrégation</a></li>
<li><a href="#bonus-une-propriete-etonnante-de-dplyr"><span class="toc-section-number">4</span> Bonus : une propriété étonnante de dplyr</a></li>
</ul>
</div>

<p>La richesse de R, alimentée par une communauté de développeurs très active, rend le choix d’une méthode adaptée à une problématique donnée difficile, et c’est tant mieux. Vous trouverez ici une modeste participation au débat qui oppose les deux packages d’analyse des données les plus en vue dans la communauté R : <code>data.table</code> et <code>dplyr</code>. Après un rappel de la syntaxe de ces packages, on les compare entre eux et avec les fonctions de R base sur un traitement tout simple issu des données du package <code>nycflights13</code>. On présente une comparaison des vitesses d’exécutions de ce traitement avec le package <code>microbenchmark</code>. On fournit ensuite un autre benchmark de <code>data.table</code> et <code>dplyr</code> sur des statistiques par groupe en faisant varier le nombre d’observations et le nombre de groupes.</p>
<div id="rappels-sur-dplyr-et-data.table" class="section level1">
<h1><span class="header-section-number">1</span> Rappels sur dplyr et data.table</h1>
<p>Si vous connaissez déjà la syntaxe de ces packages, vous pouvez directement aller à la partie <a href="#comparaisons-sur-une-etude-de-cas-simple">Comparaisons sur une étude de cas simple</a>. On rappelle ici les principales caractéristiques de ces packages mais pour se former à leur utilisation on peut se référer à l’excellent <a href="https://teaching.slmc.fr/perf/presentation_handout.pdf">cours de perfectionnement de Martin Chevalier</a>. Pour une exploration de ce qu’englobe le <code>tidyverse</code> et notamment une présentation des commandes de <code>dplyr</code>, vous pouvez jeter un oeil à <a href="https://juba.github.io/tidyverse/index.html">l’introduction à R et au tidyverse</a> de J. Barnier. Enfin pour data.table, on trouve des informations utiles sur le cours <a href="http://larmarange.github.io/analyse-R/manipulations-avancees-avec-data-table.html">Manipulations avancée avec data.table</a> de J. Larmarange.</p>
<div id="dplyr-et-le-tidyverse" class="section level2">
<h2><span class="header-section-number">1.1</span> dplyr et le tidyverse</h2>
<p>Le <code>tidyverse</code> (contraction de “tidy” et “universe”) est un concept initié par Hadley Wickham, chef statisticien de RStudio. Il regroupe un ensemble de packages utiles au traitement statistique et au nettoyage de bases de données. On va s’intéresser ici presque seulement au package <code>dplyr</code> (dont les instructions seront appliquées aux <code>tibbles</code>, un format de data.frame issu du <code>tidyverse</code>), mais vous pouvez parcourir les packages proposés dans le tidyverse sur <a href="https://www.tidyverse.org/">le site officiel</a>.<br />
<code>dplyr</code> propose un ensemble d’opérations de traitement de données sous une syntaxe différente de celle utilisée dans les fonctions de base de R. Ce langage présente le double avantage d’être à la fois lisible pour quelqu’un habitué aux langages tels que SAS ou SQL et de proposer des fonctions optimisées qui présentent de bonnes performances en termes de temps d’exécution. La grammaire <code>dplyr</code> s’appuie en effet sur des fonctions au nom explicite :</p>
<ul>
<li>mutate(data, newvar1=fonction(var1,var2…)) crée de nouvelles variables</li>
<li>filter(data, condition) sélectionne au sein d’une table certaines observations, à la manière de <code>where</code> dans SAS.</li>
<li>arrange(data, var1, descending var2,…) trie une base selon une ou plusieurs variables (l’équivalent d’une <code>proc sort</code>).</li>
<li>select(data, var1 : varX) sélectionne certaines variables dans une base, à la manière de <code>keep</code> dans SAS.</li>
<li>summarise(data, newvar1=mean(var1), newvar2=sum(var2)) réalise toute sorte d’opérations statistiques sur une table.</li>
<li>group_by(data, var) regroupe une table par une variable</li>
<li>et bien d’autres…</li>
</ul>
<p>Un aspect pratique de ce langage est que toutes ces opérations peuvent être chaînées à l’aide de l’opérateur <code>%&gt;%</code> (“pipe”) dont la syntaxe est la suivante : <code>data %&gt;% fonction(...)</code> est équivalent à <code>fonction(data, ...)</code>. Cette syntaxe permet de chaîner un grand nombre d’opérations sur une base commune, en limitant le nombre de fois où l’on écrit des tables intermédiaires tout en conservant une grande lisibilité du code. Ce petit exemple vous en convaincra peut-être :</p>
<pre class="r"><code>library(tidyverse) # On aurait aussi pu charger seulement le package dplyr
# on crée un data frame avec 100 lignes, chaque individu appartenant à un des 50 groupes
df &lt;- data.frame(id1 = c(1:100), idgpe = sample(50), replace = TRUE)

# on y applique les instructions de dplyr
df %&gt;% as_tibble() %&gt;% mutate(var = rnorm(100)) %&gt;% 
  group_by(idgpe) %&gt;% summarise(var_mean = mean(var)) -&gt; output_tibble</code></pre>
<p>Un regard peu habitué contesterait peut-être l’aspect très lisible de l’instruction, mais ça l’est réellement. Le déroulé est le suivant :</p>
<ol style="list-style-type: decimal">
<li>on transforme notre data.frame en tibble (pour rappel : format optimisé de data.frame pour dplyr) avec <code>as_tibble</code><br />
</li>
<li>on crée une variable <code>var</code> avec <code>mutate</code><br />
</li>
<li>on agrège par <code>idgpe</code> avec <code>group_by</code><br />
</li>
<li>on calcule la moyenne de <code>var</code> avec <code>summarise</code>, que l’on stocke dans <code>var_mean</code>. Comme cette instruction suit un group_by, elle est réalisée à l’intérieur de chaque groupe (défini par <code>idgpe</code>), sinon elle aurait été réalisé sur l’ensemble de la table.</li>
</ol>
<p>Tout cela est stocké dans une table output_tibble, qui est (si vous avez suivi) un tibble agrégé par <code>idgpe</code> et qui a donc 50 lignes.</p>
</div>
<div id="data.table" class="section level2">
<h2><span class="header-section-number">1.2</span> Data.table</h2>
<p>Le package <code>data.table</code> ne prétend pas, contrairement au <code>tidyverse</code>, proposer une syntaxe concurrente à base R mais enrichir celle-ci. Il est axé autour d’un nouveau format d’objet, le data.table, qui est un type de data.frame qui permet une utilisation optimisée de l’opérateur <code>[</code>.<br />
Tout data.frame peut être converti en data.table grâce à la fonction <code>as.data.table</code>, ou, de manière plus optimale pour l’utilisation de la mémoire, grâce à la fonction <code>setDT</code> qui permet de directement transformer la nature de l’objet sans avoir à en écrire un autre. Il est important d’avoir en tête qu’un data.frame converti en data.table conserve les caractéristiques d’un data.frame. Cependant, l’opérateur <code>[</code> appliqué au data.table change de signification et devient :</p>
<pre><code>DT[i,j,by]</code></pre>
<p>Avec <code>i</code> qui permet de sélectionner des observations (sans avoir besoin de répéter le nom de la base dans laquelle on se trouve), <code>j</code> qui permet de créer ou sélectionner des variables et <code>by</code> de regrouper les traitement selon les modalités d’une variable définie. Comme dans <code>dplyr</code>, il est possible de chaîner les opérations réalisées comme le montre l’exemple suivant, qui reprend le même cas de figure que celui illustrant le package <code>dplyr</code> :</p>
<pre class="r"><code>library(data.table) 
# on convertit notre data frame précédemment créé en data.table
dt &lt;- as.data.table(df)

# on y applique les même instructions
dt[, list(var_mean = mean(rnorm(100))), by = list(idgpe = idgpe)] -&gt; output_dt</code></pre>
<p>Le fait de renseigner mes variables au sein de <code>list()</code> me permet d’avoir une table en sortie au niveau de <code>idgpe</code> (donc 50 observations), sans cela ma variable est bien moyennée par groupe mais la table en sortie est toujours au niveau <code>id1</code> (100 observations).</p>
</div>
<div id="vitesses-dexecution" class="section level2">
<h2><span class="header-section-number">1.3</span> Vitesses d’exécution</h2>
<p>Voilà donc pour les présentations! Allez, on montre le résultat d’un petit <code>microbenchmark</code> des deux juste pour voir :</p>
<pre><code>## Unit: microseconds
##        expr      min        lq      mean    median        uq      max
##       dplyr 1563.879 1599.7190 1770.8408 1627.8790 1812.4835 4440.754
##  data.table  823.185  846.5085  916.2376  884.9085  989.0155 1256.110
##  neval
##    100
##    100</code></pre>
<p>Sur cet exemple, on voit un avantage clair à data.table! Mais on est sur une toute petite table en entrée. On va essayer de se rapprocher de cas plus concrets en s’intéressant à un exemple sur des bases plus importantes.</p>
</div>
</div>
<div id="comparaisons-sur-une-etude-de-cas-simple" class="section level1">
<h1><span class="header-section-number">2</span> Comparaisons sur une étude de cas simple</h1>
<p>Les avantages et inconvénients de ces deux packages sont à l’origine de nombreux débats. Vous pouvez vous en convaincre en suivant <a href="https://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly">cette discussion sur stackoverflow</a>. On peut quand même dégager deux compromis :</p>
<ul>
<li>Le choix de l’un ou l’autre des packages dépend beaucoup de ce que l’on va en faire (types d’analyses, taille des données, profils des utilisateurs du code…).<br />
</li>
<li>Les deux packages sont plus intéressants que base R pour l’analyse de données, que ce soit en termes de facilité d’écriture ou de performances.</li>
</ul>
<p>Pour ce deuxième point, on va essayer de s’en convaincre ensemble avec ce petit exemple.</p>
<div id="notre-etude-de-cas" class="section level2">
<h2><span class="header-section-number">2.1</span> Notre étude de cas</h2>
<p>Pour cet exemple, on utilise les données du package de Hadley Wickham (oui, le même qui est à l’origine du <code>tidyverse</code>, mais ça n’entamera pas notre indépendance) que l’on trouve dans <code>nycflights13</code>. En particulier, la base <code>flights</code> donne toutes les heures de départ et d’arrivée selon les aéroports de départ et d’arrivée ainsi que les retards au départ et à l’arrivée. La base <code>weather</code> donne elle des indications météo, heure par heure, dans chaque aéroport. Tout bon statisticien qui se respecte devrait commencer à se dire qu’il y a quelque chose à faire pour tenter d’expliquer les retards des avions (<em>spoiler alert</em> : on ne va pas le faire).<br />
Commençons par charger nos packages (n’oubliez pas de faire <code>install.packages(&quot;nom_pck&quot;)</code> avant si vous ne l’avez jamais fait) et nos données :</p>
<pre class="r"><code># Les packages nécessaires
library(tidyverse) # Regroupe différents packages, voir https://www.tidyverse.org/ 
library(data.table)
library(microbenchmark) # Pour les calculs de vitesse d&#39;exécution
library(nycflights13) # Pour les données

# data frame classiques pour tests en base R
flights &lt;- as.data.frame(flights)
weather &lt;- as.data.frame(weather)
# data.table pour tests avec data.table
flightsdt &lt;- as.data.table(flights)
weatherdt &lt;- as.data.table(weather)
# tibbles pour instructions en dplyR (tournent aussi sur data.frame et data.table)
flightstib &lt;- as_tibble(flights)
weathertib &lt;- as_tibble(weather)</code></pre>
<p>Notez que l’on n’est pas obligés de faire du dplyr sur des tibbles plutôt que des data frame, mais on suit ici les recommandations d’Hadley Wickham.</p>
</div>
<div id="moyenne-des-retards-et-fusion-des-tables" class="section level2">
<h2><span class="header-section-number">2.2</span> Moyenne des retards et fusion des tables</h2>
<p>Un rapide examen des bases vous montre que la première étape avant toute analyse est comme souvent de regrouper les éléments de flights par heure et aéroport de départ (ou aurait aussi pu prendre aéroport d’arrivée) pour pouvoir les fusionner avec la table weather, qui donnent les indications météo minute par minute. On écrit cette instruction de manières différentes :</p>
<p><strong>En base R</strong></p>
<pre class="r"><code>flights_time_hour &lt;- aggregate.data.frame(list(arr_delay = flights$arr_delay, 
                                    dep_delay = flights$dep_delay), 
                                      list(time_hour = flights$time_hour, origin = flights$origin), 
                                      mean)
output_base &lt;- merge(weather, flights_time_hour, by = c(&quot;time_hour&quot;, &quot;origin&quot;), sort = FALSE)</code></pre>
<p>(J’ai utilisé <code>aggregate.data.frame</code> et pas <code>tapply</code> pour avoir directement un data.frame en sortie)</p>
<p><strong>En dplyr</strong></p>
<pre class="r"><code>flightstib %&gt;% group_by(time_hour, origin) %&gt;% 
  summarise(arr_delay = mean(arr_delay),
            dep_delay = mean(dep_delay)) %&gt;% 
  inner_join(weathertib, by = c(&quot;time_hour&quot;, &quot;origin&quot;)) -&gt; output_dplyr </code></pre>
<p><strong>En data.table</strong></p>
<pre class="r"><code>output_DT &lt;- merge(flightsdt[, list(arr_perc_delay = mean(arr_delay),
                       dep_perc_delay = mean(dep_delay)), by = c(&quot;time_hour&quot;, &quot;origin&quot;)],
      weatherdt, by = c(&quot;time_hour&quot;, &quot;origin&quot;))</code></pre>
<p>J’ai utilisé la fonction <code>merge</code> plutôt que <code>DT1[DT2, on = c(&quot;time_hour&quot;, &quot;origin&quot;), nomatch = 0]</code> car j’ai constaté qu’elle était plus rapide, conformément à ce que montre bien cet <a href="https://jozefhajnala.gitlab.io/r/r006-merge/">article du Jozef’s Rblog</a>.</p>
</div>
<div id="comparaisons-des-vitesses-dexecution" class="section level2">
<h2><span class="header-section-number">2.3</span> Comparaisons des vitesses d’exécution</h2>
<p>Je vous laisse juger de la lisibilité de chacune de ces instructions, qui font toutes la même chose, car c’est finalement assez subjectif. On donne ici les résultats d’un <code>microbenchmark</code> de ces instructions :</p>
<pre><code>## Unit: milliseconds
##   expr        min         lq       mean     median         uq        max
##   Base 2315.94825 2348.88355 2403.49992 2402.69967 2455.93039 2496.03655
##  DplyR   56.12780   56.30586   57.22655   57.10714   58.27934   58.90910
##     DT   32.79023   32.97285   35.22099   33.22344   33.85235   52.62116
##  neval
##     10
##     10
##     10</code></pre>
<p>Les résultats sont très nettement en faveur des packages <code>dplyr</code> et <code>data.table</code>, ce dernier ayant l’avantage. Sans doute existe-t-il des moyens de plus optimiser l’instruction en base R, mais là n’est pas vraiment la question. On voit qu’avec une syntaxe simple et lisible, <code>dplyr</code> et <code>data.table</code> font beaucoup mieux que l’instruction qui viendrait à l’esprit d’un statisticien qui n’utiliserait que les premières fonctions venues de base R.</p>
</div>
</div>
<div id="tests-complementaires-sur-les-vitesse-daggregation" class="section level1">
<h1><span class="header-section-number">3</span> Tests complémentaires sur les vitesse d’aggrégation</h1>
<p>Comme on l’a vu dans notre petit exemple, l’aggrégation est souvent utilisée en statistiques. Il est donc intéressant de comparer les performances de <code>data.table</code> et <code>dplyr</code> de ce point de vue. Des benchamrks ont déjà été faits, et on peut les trouver dans la <a href="https://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly">discussion sur stackoverflow</a> évoquée plus haut. On propose ici quelques tests comparatifs sur un cas de groupement d’une base fictive de <code>nbrow</code> lignes appartenant à <code>nbgpe</code> groupes. La fonction est la suivante :</p>
<pre class="r"><code>test_group_by &lt;- function(nbrow, nbgpe){
  test &lt;- as_tibble(data.frame(x = rnorm(nbrow), y = sample(floor(nbgpe), replace = TRUE)))
  testDT &lt;- as.data.table(test)
  
  return(autoplot(
    microbenchmark::microbenchmark(times = 10, unit=&quot;ms&quot;, 
                                   DplyR = test %&gt;% group_by(y) %&gt;% summarise(x = mean(x)),
                                   data.table = testDT[, x:= mean(x), by = y]),
    title = paste0(&quot;Benchmark avec table de &quot;, nbrow, &quot; observations (100 itérations)&quot;)))
}</code></pre>
<p>Notez qu’on en profite pour se faire mousser facilement avec <code>autoplot</code> de <code>ggplot2</code> qui sort les résultats de <code>microbenchmark</code> sous forme d’un joli graphique.</p>
<p>Il n’y a plus qu’à tester! On propose des tests sur 10 000, 100 000 et 1 million de lignes avec à chaque fois peu (1/1000e du nombre de lignes) ou beaucoup (la moitié du nombre de lignes) de groupes.</p>
<p><strong>10 000 lignes pour 10 groupes</strong> <img src="/post/benchmark_DT_dplyr_base_102018_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p><strong>10 000 lignes pour 5 000 groupes</strong> <img src="/post/benchmark_DT_dplyr_base_102018_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p><strong>100 000 lignes pour 100 groupes</strong> <img src="/post/benchmark_DT_dplyr_base_102018_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p><strong>100 000 lignes pour 50 000 groupes</strong> <img src="/post/benchmark_DT_dplyr_base_102018_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p><strong>1 million de lignes pour 1 000 groupes</strong> <img src="/post/benchmark_DT_dplyr_base_102018_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p><strong>1 million de lignes pour 500 000 groupes</strong> <img src="/post/benchmark_DT_dplyr_base_102018_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
</div>
<div id="bonus-une-propriete-etonnante-de-dplyr" class="section level1">
<h1><span class="header-section-number">4</span> Bonus : une propriété étonnante de dplyr</h1>
<p>Je partage ici un aspect qui m’a semblé étonnant de dplyr. Si je reprends l’exemple donné en première partie de cet article, vous avez pu remarquer que :</p>
<pre class="r"><code># Rappel : df &lt;- data.frame(id1 = c(1:100), idgpe = sample(50), replace = TRUE)
  df %&gt;% as_tibble() %&gt;% mutate(var = rnorm(100)) %&gt;% 
    group_by(idgpe) %&gt;% summarise(var_mean = mean(var)) -&gt; output_tibble</code></pre>
<p>pouvait se réécrire de manière plus directe (comme le fait d’ailleurs la partie sur data.table) ainsi :</p>
<pre class="r"><code>  df %&gt;% as_tibble() %&gt;%  group_by(idgpe) %&gt;% 
  summarise(var_mean = mean(rnorm(100))) -&gt; output_tibble</code></pre>
<p>c’est-à-dire en se passant du <code>mutate</code> pour remplacer <code>var</code> par sa valeur dans <code>summarise</code>.<br />
Et bien, je n’ai pas seulement écrit cette instruction ainsi pour le plaisir de vous montrer la fonction <code>mutate</code>, mais aussi parce que la première option est bien plus rapide que la seconde, comme le montre <code>microbenchmark</code> :</p>
<pre class="r"><code>microbenchmark::microbenchmark(times=100L, dplyr1 = {
  df %&gt;% as_tibble() %&gt;% mutate(var = rnorm(100)) %&gt;% 
    group_by(idgpe) %&gt;% summarise(var_mean = mean(var)) -&gt; output_tibble
}, dplyr2 = {
  df %&gt;% as_tibble() %&gt;% group_by(idgpe) %&gt;% 
    summarise(var_mean = mean(rnorm(100))) -&gt; output_tibble
})
## Unit: milliseconds
##    expr      min       lq     mean   median       uq      max neval
##  dplyr1 1.547381 1.564164 1.783237 1.584642 1.652057 7.260741   100
##  dplyr2 2.627133 2.646760 2.731053 2.682031 2.738067 3.645446   100</code></pre>
<p>Ca peut sembler secondaire pour cet exemple, mais sur des grosses tables la différence va vraiment peser. Regardons par exemple les différences de performance de deux instructions <code>dplyr</code> agrégeant par heure une variable égale au pourcentage de retard à l’arrivée par rapport à la durée du vol :</p>
<pre class="r"><code>microbenchmark::microbenchmark(times=10L, dplyr_mutate = {
  flightstib %&gt;% mutate(propor_delay = arr_delay / air_time) %&gt;% 
    group_by(time_hour) %&gt;% 
    summarise(propor_delay = mean(propor_delay)) -&gt; output_dplyr 
}, dplyr_sans_mutate = {
  flightstib %&gt;% group_by(time_hour) %&gt;% 
    summarise(propor_delay = mean(arr_delay / air_time)) -&gt; output_dplyr 
})
## Unit: milliseconds
##               expr       min        lq      mean    median        uq
##       dplyr_mutate  24.30695  24.75524  26.28822  25.38443  26.76342
##  dplyr_sans_mutate 220.76675 222.62304 225.37140 223.67719 226.90336
##        max neval
##   33.95305    10
##  239.39675    10</code></pre>
<p>Les performances changent du tout au tout. Je n’ai pas d’explications à cela et je n’étais pas conscient de cette propriété de <code>summarise</code>, mais cela montre visiblement que cela doit être une mauvais pratique de définir une variable au sein d’un summarise. Cela semble être un aspect important à avoir en tête quand on code en <code>dplyr</code>!</p>
</div>

    </div>

    


<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/dplyr/">dplyr</a>
  
  <a class="badge badge-light" href="/tags/tidyverse/">tidyverse</a>
  
  <a class="badge badge-light" href="/tags/data.table/">data.table</a>
  
  <a class="badge badge-light" href="/tags/microbenchmark/">microbenchmark</a>
  
  <a class="badge badge-light" href="/tags/benchmark/">benchmark</a>
  
  <a class="badge badge-light" href="/tags/data-science/">data science</a>
  
</div>




    
    
    <div class="article-widget">
      <div class="hr-light"></div>
      <h3>Sur le même sujet</h3>
      <ul>
        
        <li><a href="/post/comparaisons-dplyr-data-table-base-r/">Comparaisons dplyr - data.table - base R</a></li>
        
      </ul>
    </div>
    

    

    


  </div>
</article>

<div class="container">
  <footer class="site-footer">
  
  <p class="powered-by">
    <a href="/privacy/">Privacy Policy</a>
  </p>
  

  <p class="powered-by">
    &copy; 2018 &middot; 

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" id="back_to_top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

</div>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Citation</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copier
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Télécharger
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha512-+NqPlbbtM1QqiK8ZAo4Yrj2c4lNQoGv8P79DPtKzj++l5jnN39rHA/xsqn8zE9l0uSoxaCdrOgFs6yjyfbBxSg==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
        
      

      
      
    

    <script src="/js/hugo-academic.js"></script>
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "",
        'results': "",
        'no_results': ""
      };
      const content_type = {
        'post': "Posts",
        'project': "Projets",
        'publication' : "Publications",
        'talk' : "Présentations"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    <script src="/js/search.js"></script>
    

    
    

  </body>
</html>

